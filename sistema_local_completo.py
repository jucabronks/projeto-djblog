#!/usr/bin/env python3
"""
Sistema Local Completo - Agregador de Not√≠cias
Simula todas as funcionalidades do projeto sem AWS
"""

import feedparser
import json
import time
import schedule
from datetime import datetime, timedelta
from difflib import SequenceMatcher
import logging
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# Configura√ß√µes
ARQUIVO_NOTICIAS = "noticias_local.json"
ARQUIVO_FONTES = "fontes_local.json"
ARQUIVO_LOG = "sistema_local.log"

# Fontes expandidas (subconjunto das principais)
FONTES_SISTEMA = [
    # Tecnologia
    {"name": "TechCrunch", "rss": "https://techcrunch.com/feed/", "nicho": "tecnologia", "ativo": True},
    {"name": "The Verge", "rss": "https://www.theverge.com/rss/index.xml", "nicho": "tecnologia", "ativo": True},
    
    # Ci√™ncia
    {"name": "Nature", "rss": "https://www.nature.com/nature.rss", "nicho": "ciencia", "ativo": True},
    {"name": "BBC Science", "rss": "https://feeds.bbci.co.uk/news/science_and_environment/rss.xml", "nicho": "ciencia", "ativo": True},
    
    # Startups
    {"name": "VentureBeat", "rss": "https://venturebeat.com/feed/", "nicho": "startups", "ativo": True},
    
    # IA
    {"name": "MIT Technology Review", "rss": "https://www.technologyreview.com/feed", "nicho": "ia", "ativo": True},
    
    # Internacional
    {"name": "The Guardian", "rss": "https://www.theguardian.com/world/rss", "nicho": "internacional", "ativo": True},
    {"name": "BBC News", "rss": "https://feeds.bbci.co.uk/news/rss.xml", "nicho": "internacional", "ativo": True},
]

class SistemaLocalNoticias:
    def __init__(self):
        self.noticias = self.carregar_noticias()
        self.fontes = FONTES_SISTEMA
        self.log_file = ARQUIVO_LOG
        
    def carregar_noticias(self):
        """Carrega not√≠cias do arquivo JSON"""
        try:
            if os.path.exists(ARQUIVO_NOTICIAS):
                with open(ARQUIVO_NOTICIAS, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"Erro ao carregar not√≠cias: {e}")
        return []
    
    def salvar_noticias(self):
        """Salva not√≠cias no arquivo JSON"""
        try:
            with open(ARQUIVO_NOTICIAS, 'w', encoding='utf-8') as f:
                json.dump(self.noticias, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Erro ao salvar not√≠cias: {e}")
    
    def log_evento(self, mensagem):
        """Registra evento no log"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] {mensagem}\n"
        
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(log_entry)
        except Exception as e:
            print(f"Erro ao escrever log: {e}")
    
    def checar_plagio_local(self, title, resumo):
        """Verifica pl√°gio local"""
        for noticia in self.noticias:
            sim_titulo = SequenceMatcher(None, noticia.get("titulo", ""), title).ratio()
            sim_resumo = SequenceMatcher(None, noticia.get("resumo", ""), resumo).ratio()
            if sim_titulo > 0.8 or sim_resumo > 0.8:
                return True
        return False
    
    def coletar_noticias(self):
        """Coleta not√≠cias das fontes RSS"""
        self.log_evento("üöÄ Iniciando coleta de not√≠cias")
        
        total_salvas = 0
        total_existentes = 0
        
        for fonte in self.fontes:
            if not fonte.get("ativo", True):
                continue
                
            try:
                self.log_evento(f"üì∞ Coletando de: {fonte['name']} ({fonte['nicho']})")
                feed = feedparser.parse(fonte["rss"])
                
                if not feed.entries:
                    self.log_evento(f"‚ö†Ô∏è  {fonte['name']}: Sem not√≠cias dispon√≠veis")
                    continue
                
                for entry in feed.entries[:3]:  # M√°ximo 3 not√≠cias por fonte
                    title = entry.get("title", "(Sem t√≠tulo)")
                    link = entry.get("link", "")
                    description = entry.get("summary", "")
                    
                    # Criar resumo
                    resumo = " ".join(description.split()[:60]) + ("..." if len(description.split()) > 60 else "")
                    
                    # Verificar se j√° existe
                    if any(n["link"] == link for n in self.noticias):
                        total_existentes += 1
                        continue
                    
                    # Verificar pl√°gio
                    is_plagio = self.checar_plagio_local(title, resumo)
                    
                    if not is_plagio:
                        noticia = {
                            "titulo": title,
                            "link": link,
                            "resumo": resumo,
                            "fonte": fonte["name"],
                            "nicho": fonte["nicho"],
                            "data_insercao": datetime.now().isoformat(),
                            "aprovado": True,
                            "plagio_local": False,
                            "publicado": False
                        }
                        
                        self.noticias.append(noticia)
                        total_salvas += 1
                        self.log_evento(f"‚úÖ {fonte['name']}: {title[:50]}...")
                    else:
                        total_existentes += 1
                        self.log_evento(f"‚ùå {fonte['name']}: {title[:50]}... (duplicada)")
                        
            except Exception as e:
                self.log_evento(f"‚ùå Erro ao coletar de {fonte['name']}: {e}")
        
        self.salvar_noticias()
        self.log_evento(f"üìä Coleta conclu√≠da: {total_salvas} salvas, {total_existentes} existentes")
        return total_salvas, total_existentes
    
    def limpar_noticias_antigas(self):
        """Remove not√≠cias com mais de 7 dias"""
        self.log_evento("üßπ Iniciando limpeza de not√≠cias antigas")
        
        data_limite = datetime.now() - timedelta(days=7)
        noticias_antes = len(self.noticias)
        
        self.noticias = [
            n for n in self.noticias 
            if datetime.fromisoformat(n["data_insercao"]) > data_limite
        ]
        
        noticias_removidas = noticias_antes - len(self.noticias)
        self.salvar_noticias()
        
        self.log_evento(f"üßπ Limpeza conclu√≠da: {noticias_removidas} not√≠cias removidas")
        return noticias_removidas
    
    def health_check_fontes(self):
        """Verifica se as fontes RSS est√£o funcionando"""
        self.log_evento("üîç Iniciando health check das fontes")
        
        fontes_quebradas = []
        
        for fonte in self.fontes:
            try:
                feed = feedparser.parse(fonte["rss"])
                if not feed.entries:
                    fontes_quebradas.append(fonte["name"])
                    self.log_evento(f"‚ö†Ô∏è  {fonte['name']}: Sem not√≠cias")
                else:
                    self.log_evento(f"‚úÖ {fonte['name']}: OK ({len(feed.entries)} not√≠cias)")
            except Exception as e:
                fontes_quebradas.append(fonte["name"])
                self.log_evento(f"‚ùå {fonte['name']}: Erro - {e}")
        
        if fontes_quebradas:
            self.log_evento(f"‚ö†Ô∏è  Fontes com problemas: {', '.join(fontes_quebradas)}")
        else:
            self.log_evento("‚úÖ Todas as fontes est√£o funcionando")
        
        return len(fontes_quebradas) == 0
    
    def publicar_noticias(self):
        """Simula publica√ß√£o de not√≠cias (1 por nicho)"""
        self.log_evento("üì§ Iniciando publica√ß√£o de not√≠cias")
        
        nichos_publicados = set()
        publicadas = 0
        
        # Ordenar por data de inser√ß√£o (mais recentes primeiro)
        noticias_ordenadas = sorted(
            [n for n in self.noticias if n["aprovado"] and not n["publicado"]],
            key=lambda x: x["data_insercao"],
            reverse=True
        )
        
        for noticia in noticias_ordenadas:
            if noticia["nicho"] not in nichos_publicados:
                noticia["publicado"] = True
                noticia["data_publicacao"] = datetime.now().isoformat()
                nichos_publicados.add(noticia["nicho"])
                publicadas += 1
                
                self.log_evento(f"üì§ Publicada: {noticia['titulo'][:50]}... ({noticia['nicho']})")
        
        self.salvar_noticias()
        self.log_evento(f"üì§ Publica√ß√£o conclu√≠da: {publicadas} not√≠cias publicadas")
        return publicadas
    
    def mostrar_estatisticas(self):
        """Mostra estat√≠sticas do sistema"""
        if not self.noticias:
            print("Nenhuma not√≠cia no sistema.")
            return
        
        print("\nüìä ESTAT√çSTICAS DO SISTEMA")
        print("=" * 50)
        
        # Estat√≠sticas gerais
        total = len(self.noticias)
        aprovadas = len([n for n in self.noticias if n["aprovado"]])
        publicadas = len([n for n in self.noticias if n.get("publicado", False)])
        
        print(f"üì∞ Total de not√≠cias: {total}")
        print(f"‚úÖ Aprovadas: {aprovadas}")
        print(f"üì§ Publicadas: {publicadas}")
        print(f"‚è≥ Aguardando: {aprovadas - publicadas}")
        
        # Por nicho
        nichos = {}
        for noticia in self.noticias:
            nicho = noticia["nicho"]
            nichos[nicho] = nichos.get(nicho, 0) + 1
        
        print(f"\nüìà POR NICHO:")
        for nicho, count in sorted(nichos.items()):
            print(f"  {nicho.capitalize()}: {count} not√≠cias")
        
        # Por fonte
        fontes = {}
        for noticia in self.noticias:
            fonte = noticia["fonte"]
            fontes[fonte] = fontes.get(fonte, 0) + 1
        
        print(f"\nüì∞ POR FONTE:")
        for fonte, count in sorted(fontes.items()):
            print(f"  {fonte}: {count} not√≠cias")
    
    def executar_ciclo_completo(self):
        """Executa um ciclo completo do sistema"""
        print("üîÑ EXECUTANDO CICLO COMPLETO DO SISTEMA")
        print("=" * 60)
        
        # 1. Coletar not√≠cias
        salvas, existentes = self.coletar_noticias()
        print(f"üì∞ Coleta: {salvas} novas, {existentes} existentes")
        
        # 2. Health check
        health_ok = self.health_check_fontes()
        print(f"üîç Health check: {'‚úÖ OK' if health_ok else '‚ùå Problemas'}")
        
        # 3. Publicar not√≠cias
        publicadas = self.publicar_noticias()
        print(f"üì§ Publica√ß√£o: {publicadas} not√≠cias")
        
        # 4. Mostrar estat√≠sticas
        self.mostrar_estatisticas()
        
        print("\n‚úÖ Ciclo completo executado com sucesso!")

def agendar_tarefas(sistema):
    """Agenda as tarefas do sistema"""
    # Coleta: 4x por dia
    schedule.every().day.at("20:00").do(sistema.coletar_noticias)
    schedule.every().day.at("20:10").do(sistema.coletar_noticias)
    schedule.every().day.at("20:20").do(sistema.coletar_noticias)
    schedule.every().day.at("20:30").do(sistema.coletar_noticias)
    
    # Publica√ß√£o: 3x por semana √†s 6:40
    schedule.every().monday.at("06:40").do(sistema.publicar_noticias)
    schedule.every().tuesday.at("06:40").do(sistema.publicar_noticias)
    schedule.every().wednesday.at("06:40").do(sistema.publicar_noticias)
    schedule.every().friday.at("06:40").do(sistema.publicar_noticias)
    
    # Limpeza: Domingo √†s 3:00
    schedule.every().sunday.at("03:00").do(sistema.limpar_noticias_antigas)
    
    # Health check: Di√°rio √†s 8:00
    schedule.every().day.at("08:00").do(sistema.health_check_fontes)

def main():
    """Fun√ß√£o principal"""
    print("üéØ SISTEMA LOCAL COMPLETO - AGREGA√á√ÉO DE NOT√çCIAS")
    print("=" * 70)
    print("Este sistema simula todas as funcionalidades do projeto:")
    print("  ‚úÖ Coleta autom√°tica de RSS")
    print("  ‚úÖ Verifica√ß√£o de pl√°gio")
    print("  ‚úÖ Publica√ß√£o por nicho")
    print("  ‚úÖ Limpeza autom√°tica")
    print("  ‚úÖ Health check das fontes")
    print("  ‚úÖ Agendamento de tarefas")
    print("  ‚úÖ Logs e estat√≠sticas")
    print("=" * 70)
    
    sistema = SistemaLocalNoticias()
    
    # Executar ciclo inicial
    sistema.executar_ciclo_completo()
    
    # Perguntar se quer agendar tarefas
    resposta = input("\nü§î Quer agendar as tarefas para execu√ß√£o autom√°tica? (s/n): ")
    
    if resposta.lower() in ['s', 'sim', 'y', 'yes']:
        print("\n‚è∞ Agendando tarefas...")
        agendar_tarefas(sistema)
        
        print("üìÖ Tarefas agendadas:")
        print("  üì∞ Coleta: 20:00, 20:10, 20:20, 20:30 (di√°rio)")
        print("  üì§ Publica√ß√£o: 6:40 (seg, ter, qua, sex)")
        print("  üßπ Limpeza: 3:00 (domingo)")
        print("  üîç Health check: 8:00 (di√°rio)")
        
        print("\nüîÑ Sistema rodando... Pressione Ctrl+C para parar")
        
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)  # Verificar a cada minuto
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Sistema parado pelo usu√°rio")
    else:
        print("\n‚úÖ Sistema executado uma vez. Use 'python sistema_local_completo.py' para executar novamente.")

if __name__ == "__main__":
    main() 